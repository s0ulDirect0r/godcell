<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Three.js Creature Viewer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>

  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
</script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510); // Deep dark blue background

    // Fog to blend the grid into the distance
    scene.fog = new THREE.Fog(0x050510, 10, 30);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(8, 6, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    // Enable shadow mapping for realistic depth
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(2, 0, 0);

    // --- Environment & Lighting ---

    // 1. Grid Floor mimicking the reference image
    const gridHelper = new THREE.GridHelper(50, 50, 0x111133, 0x111133);
    scene.add(gridHelper);

    // 2. Base Lighting (Subtle)
    const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
    scene.add(ambientLight);

    // Directional light from top-left to define the white shapes
    const mainLight = new THREE.DirectionalLight(0xffffff, 0.5);
    mainLight.position.set(-5, 10, 5);
    mainLight.castShadow = true;
    scene.add(mainLight);


    // --- Creature Definition ---

    const creatureGroup = new THREE.Group();
    // Shift creature up slightly so legs rest near the grid
    creatureGroup.position.y = 1.2;
    scene.add(creatureGroup);

    // Materials
    const bodyMaterial = new THREE.MeshStandardMaterial({
      color: 0xdddddd, // White/light grey
      roughness: 0.4,   // Looks like plastic/ matte metal
      metalness: 0.1,
    });

    // The glowing green material
    const glowMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      emissive: 0x00ff00, // This makes it look bright even without light hitting it
      emissiveIntensity: 5, // How bright the glow appears
      roughness: 0.1,
      metalness: 0.0
    });

    // Helper function to add a real light source wherever we have glowing geometry
    function addGlowLight(mesh, intensity = 2, distance = 5) {
      const light = new THREE.PointLight(0x00ff00, intensity, distance);
      light.castShadow = false; // Glowing parts usually don't cast harsh shadows
      mesh.add(light);
    }

    // --- Building the Anatomy ---

    // 1. The Head & Eye
    const headGeo = new THREE.SphereGeometry(1.8, 32, 32);
    const headMesh = new THREE.Mesh(headGeo, bodyMaterial);
    headMesh.position.set(-3, 0, 0);
    headMesh.castShadow = true;
    creatureGroup.add(headMesh);

    const eyeGeo = new THREE.SphereGeometry(0.8, 24, 24);
    const eyeMesh = new THREE.Mesh(eyeGeo, glowMaterial);
    // Position eye on the front-left of the head
    eyeMesh.position.set(-1.4, 0.3, 0.8);
    headMesh.add(eyeMesh);
    addGlowLight(eyeMesh, 3, 7);


    // 2. The Segmented Body & Glowing Nuclei
    // We create 3 overlapping segments
    for (let i = 0; i < 3; i++) {
      // Decrease size slightly for each segment backwards
      const scaleFactor = 1 - (i * 0.15);

      // Use sphere flattened on Y axis for segment look
      const segmentGeo = new THREE.SphereGeometry(1.4 * scaleFactor, 24, 24);
      segmentGeo.scale(1, 0.7, 1);

      const segmentMesh = new THREE.Mesh(segmentGeo, bodyMaterial);
      // Position segments along the X axis
      segmentMesh.position.set(-0.5 + (i * 2), 0, 0);
      segmentMesh.castShadow = true;
      segmentMesh.receiveShadow = true;
      creatureGroup.add(segmentMesh);

      // Add the glowing orb on top of the segment
      const orbGeo = new THREE.SphereGeometry(0.4 * scaleFactor, 16, 16);
      const orbMesh = new THREE.Mesh(orbGeo, glowMaterial);
      // Position on the "dorsal" (top) side
      orbMesh.position.set(0, 0.8 * scaleFactor, 0);
      segmentMesh.add(orbMesh);
      addGlowLight(orbMesh, 1.5, 4);
    }

    // 3. The Tail & Spikes
    let tailPosX = 4.5;
    let tailPosY = 0.2;
    let tailSize = 0.8;

    // Create a chain of 5 tail segments curving up
    for (let i = 0; i < 5; i++) {
      const tailSegGeo = new THREE.SphereGeometry(tailSize, 16, 16);
      const tailSegMesh = new THREE.Mesh(tailSegGeo, bodyMaterial);
      tailSegMesh.position.set(tailPosX, tailPosY, 0);
      tailSegMesh.castShadow = true;
      creatureGroup.add(tailSegMesh);

      // Add spike
      const spikeGeo = new THREE.ConeGeometry(tailSize * 0.3, tailSize * 1.2, 8);
      const spikeMesh = new THREE.Mesh(spikeGeo, bodyMaterial);
      spikeMesh.position.set(0, tailSize * 0.8, 0);
      tailSegMesh.add(spikeMesh);

      // Calculate next position (move right and curve up)
      tailPosX += tailSize * 1.3;
      tailPosY += tailSize * 0.4;
      tailSize *= 0.85; // Shrink next segment
    }

    // The large glow orb at the tip of the tail
    const tailTipGeo = new THREE.SphereGeometry(1.0, 24, 24);
    const tailTipMesh = new THREE.Mesh(tailTipGeo, glowMaterial);
    tailTipMesh.position.set(tailPosX + 0.5, tailPosY + 0.5, 0);
    creatureGroup.add(tailTipMesh);
    addGlowLight(tailTipMesh, 4, 10);


    // 4. The Legs (6 total)
    function createLeg(sideMultiplier) {
      // sideMultiplier: 1 for left side (Z+), -1 for right side (Z-)
      const legGroup = new THREE.Group();

      // A simplified 3-part leg using Capsule geometries for joints
      const legRadius = 0.35;
      const jointMat = bodyMaterial;

      // Thigh (Upper leg pointing out and up)
      const thighGeo = new THREE.CapsuleGeometry(legRadius, 1.2, 8, 16);
      const thigh = new THREE.Mesh(thighGeo, jointMat);
      thigh.position.set(0, 0.5, sideMultiplier * 0.5);
      thigh.rotation.z = Math.PI / 4; // Angle out away from body
      thigh.rotation.x = -sideMultiplier * Math.PI / 8; // slight twist
      thigh.castShadow = true;
      legGroup.add(thigh);

      // Shin (Lower leg pointing down)
      const shinGeo = new THREE.CapsuleGeometry(legRadius * 0.9, 1.5, 8, 16);
      const shin = new THREE.Mesh(shinGeo, jointMat);
      // Position relative to end of thigh
      shin.position.set(0.8, -0.5, sideMultiplier * 0.8);
      shin.rotation.z = -Math.PI / 3; // Angle down towards ground
      shin.castShadow = true;
      legGroup.add(shin);

      // Foot/Claw
      const clawGeo = new THREE.ConeGeometry(legRadius, 0.8, 8);
      const claw = new THREE.Mesh(clawGeo, jointMat);
      claw.position.set(1.3, -1.6, sideMultiplier * 0.9);
      // Point claw downwards
      claw.rotation.x = Math.PI / 2;
      claw.castShadow = true;
      legGroup.add(claw);

      return legGroup;
    }

    // Attach legs to specific body positions along X axis
    const legPositionsX = [-1, 1, 3];

    legPositionsX.forEach((posX, index) => {
      // Left Leg
      const leftLeg = createLeg(1);
      leftLeg.position.set(posX, -0.2, 1.2);
      // Rotate front/back legs slightly for a more dynamic stance
      leftLeg.rotation.y = (index - 1) * -0.3;
      creatureGroup.add(leftLeg);

      // Right Leg
      const rightLeg = createLeg(-1);
      rightLeg.position.set(posX, -0.2, -1.2);
      rightLeg.rotation.y = (index - 1) * 0.3;
      creatureGroup.add(rightLeg);
    });


    // --- Animation Loop ---

    window.addEventListener('resize', onWindowResize, false);

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Subtle floating motion for the whole creature
      const time = Date.now() * 0.001;
      creatureGroup.position.y = 1.2 + Math.sin(time) * 0.1;
      // Subtle tail wag
      tailTipMesh.position.y += Math.sin(time * 2) * 0.01;

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

  </script>
</body>

</html>